// Generated by CoffeeScript 1.8.0
(function() {
  var add_prefix_to_trie, byte_array, byte_dict, byte_trie, convert_digit, digit, find_first_prefix, find_longest_prefix, lead_byte_array, lead_byte_dict, lead_byte_trie, letter, parse, parse_byte, parse_lead_byte, parse_whitespace, self, str, _i, _j, _len, _len1, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  self = typeof exports !== 'undefined' ? exports : window;

  byte_array = ['blank', 'blank2', 1, 'A', 'B', 'C', 'D', '/', 'E', 'F', 'G', 'H', 'I', 2, 'J', 'K', 'L', 'M', 'N', 5, 'O', 'P', 'Q', 'R', 'S', 3, 'T', 'U', 'V', 'W', 'X', 6, 'Z', 'Y', 'heart', '€', '$', 4, '£', '¥', '+', '?', '!', 'trip_advisor_full_bubble', '&', '@', '#', '->', ':', 0, '.', 9, 'blank3', 'full_star', 'half_star', 'empty_star', 'blank4', 8, 'percent', 7];

  lead_byte_array = ['blank', 'like_pt', 'like_ru', 7, 'like_fr', 'like_us_en', 'like_en', 'like_ko', 'like_ja', 8, 'like_zh', 'follow_us_es', 'follow_us_pt', 'follow_us_ru', 'follow_us_fr', 9, 'follow_us_en', 'follow_us_it', 'follow_us_de', 'follow_us_jp', 'follow_us_ko', 'follow_us_zh', 'check_in_pt', 'check_in_ru', 'check_in_jp', 'check_in_ko', 'check_in_zh', 'check_in_en', 1, '#', 'twitter', 'google_plus', 'youtube', 2, 'instagram', 'google_stats', 'vkontakte', 'foursquare', 'swarm', 3, 'yelp', 'blank2', 'weibo', 'dianping', 'facebook', 4, 'smiley', 'facebook_thumb', 'thx_es', 'thx_pt', 'thx_ru', 5, 'thx_fr', 'thx_en', 'thx_it', 'thx_de', 'thx_ja', 6, 'thx_ko', 'thx_zh'];

  self.lead_byte_array = lead_byte_array;

  self.byte_array = byte_array;

  self.numToFlapSymbols = function(val, n_syms) {
    var frac_n_digits, int_n_digits, suffix, sval, symbols;
    if (n_syms == null) {
      n_syms = 6;
    }
    sval = val.toString();
    suffix = null;
    if (sval.length > n_syms) {
      if (val < 1000000) {
        val = val / 1000;
        suffix = 'K';
      } else if (val < 1000000000) {
        val = val / 1000000;
        suffix = 'M';
      } else if (val < 1000000000000) {
        val = val / 1000000000;
        suffix = 'B';
      } else {
        throw "Cannot convert '" + val + "' to symbols. Too large.";
      }
      int_n_digits = val.toFixed(0).length;
      if (int_n_digits > n_syms - 1) {
        throw "Cannot represent '" + val + "' with " + n_syms + " symbols!";
      } else if (int_n_digits === n_syms - 1) {
        frac_n_digits = 0;
      } else {
        frac_n_digits = n_syms - 1 - int_n_digits - 1;
      }
      sval = val.toFixed(frac_n_digits);
    }
    symbols = sval.split('').map(function(x) {
      if (Number.isNaN(Number(x))) {
        return x;
      } else {
        return Number(x);
      }
    });
    if (suffix) {
      symbols.push(suffix);
    }
    while (symbols.length < n_syms) {
      symbols.unshift('blank');
    }
    return symbols;
  };

  convert_digit = function(i) {
    var digits, ind;
    digits = '0123456789';
    ind = digits.indexOf(i);
    if (ind !== -1) {
      return ind;
    } else {
      return i;
    }
  };

  lead_byte_dict = {
    ':)': 'smiley',
    ':-)': 'smiley',
    thumbsup: 'facebook_thumb',
    '(y)': 'facebook_thumb',
    thankyou: 'thx_en',
    like: 'like_en',
    likeus: 'like_us_en',
    like_us_de: 'like_en',
    like_us_it: 'like_en',
    like_us_es: 'follow_us_es',
    followus: 'follow_us_en',
    checkin: 'check_in_en',
    check_in_de: 'check_in_en',
    check_in_es: 'check_in_en',
    check_in_fr: 'check_in_en',
    check_in_it: 'check_in_en'
  };

  self.lead_byte_dict = lead_byte_dict;

  lead_byte_array.map(function(curr) {
    return lead_byte_dict[curr] = curr;
  });

  byte_dict = {
    '(<3)': 'heart',
    '(heart)': 'heart',
    '_': 'blank',
    '%': 'percent',
    '(percent)': 'percent',
    '(euro)': '€',
    '(dollar)': '$',
    '(pound)': '£',
    '(yen)': '¥',
    '(plus)': '+',
    '(question)': '?',
    '(exclamation)': '!',
    '(ampersand)': '&',
    '(at)': '@',
    '(hash)': '#',
    '(arrow)': '->',
    '(colon)': ':',
    '(period)': '.',
    '(star)': 'full_star',
    '*': 'full_star',
    '(half star)': 'half_star',
    '(empty star)': 'empty_star'
  };

  self.byte_dict = byte_dict;

  byte_array.map(function(curr) {
    return byte_dict[curr] = curr;
  });

  _ref = 'abcdefghijklmnopqrstuvwxyz';
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    letter = _ref[_i];
    byte_dict[letter] = letter.toUpperCase();
  }

  _ref1 = '0123456789';
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    digit = _ref1[_j];
    byte_dict[digit] = Number(digit);
  }

  add_prefix_to_trie = function(trie, prefix, end_symbol) {
    var cur, len, letter_pos, pos, _k, _len2, _results;
    if (end_symbol == null) {
      end_symbol = '$$';
    }
    cur = trie;
    len = prefix.length;
    _results = [];
    for (letter_pos = _k = 0, _len2 = prefix.length; _k < _len2; letter_pos = ++_k) {
      letter = prefix[letter_pos];
      pos = cur[letter];
      if (pos == null) {
        if (letter_pos === len - 1) {
          cur[letter] = end_symbol;
        } else {
          cur[letter] = {};
        }
        _results.push(cur = cur[letter]);
      } else if (pos === end_symbol) {
        cur[letter] = {};
        cur = cur[letter];
        _results.push(cur[end_symbol] = end_symbol);
      } else {
        cur = cur[letter];
        if (letter_pos === len - 1) {
          _results.push(cur[end_symbol] = end_symbol);
        } else {
          _results.push(void 0);
        }
      }
    }
    return _results;
  };

  find_first_prefix = function(trie, string, end_symbol) {
    var cur, x, x_pos, _k, _len2;
    if (end_symbol == null) {
      end_symbol = '$$';
    }
    cur = trie;
    for (x_pos = _k = 0, _len2 = string.length; _k < _len2; x_pos = ++_k) {
      x = string[x_pos];
      if ((cur === end_symbol) || (cur[end_symbol] != null)) {
        return string.slice(0, x_pos);
      } else if (cur[x] == null) {
        return null;
      } else {
        cur = cur[x];
      }
    }
    if (cur === end_symbol || (cur[end_symbol] != null)) {
      return string;
    }
  };

  find_longest_prefix = function(trie, string, end_symbol) {
    var cur, matched, x, x_pos, _k, _len2;
    if (end_symbol == null) {
      end_symbol = '$$';
    }
    cur = trie;
    matched = null;
    for (x_pos = _k = 0, _len2 = string.length; _k < _len2; x_pos = ++_k) {
      x = string[x_pos];
      if ((cur === end_symbol) || (cur[end_symbol] != null)) {
        matched = string.slice(0, x_pos);
      }
      if (cur[x] == null) {
        return matched;
      } else {
        cur = cur[x];
      }
    }
    if (cur === end_symbol || (cur[end_symbol] != null)) {
      matched = string;
    }
    return matched;
  };

  lead_byte_trie = {};

  for (str in lead_byte_dict) {
    if (!__hasProp.call(lead_byte_dict, str)) continue;
    add_prefix_to_trie(lead_byte_trie, str);
  }

  byte_trie = {};

  for (str in byte_dict) {
    if (!__hasProp.call(byte_dict, str)) continue;
    add_prefix_to_trie(byte_trie, str);
  }

  parse_lead_byte = function(string) {
    var lead_byte, matched;
    matched = find_longest_prefix(lead_byte_trie, string);
    if (matched == null) {
      return null;
    }
    lead_byte = lead_byte_dict[matched];
    return [lead_byte, string.slice(matched.length)];
  };

  parse_byte = function(string) {
    var matched;
    matched = find_longest_prefix(byte_trie, string);
    if (matched == null) {
      return null;
    }
    return [byte_dict[matched], string.slice(matched.length)];
  };

  parse_whitespace = function(string) {
    return string.trim();
  };

  parse = function(string) {
    var n_blanks_on_left, normal_syms, result, syms, x, _k;
    string = string.toLowerCase();
    syms = [];
    normal_syms = [];
    result = parse_lead_byte(string);
    if (result == null) {
      return null;
    }
    syms.push(result[0]);
    result = parse_whitespace(result[1]);
    while (result !== '') {
      result = parse_byte(result);
      if (result == null) {
        return null;
      }
      normal_syms.push(result[0]);
      result = parse_whitespace(result[1]);
    }
    n_blanks_on_left = 6 - normal_syms.length;
    if (n_blanks_on_left < 0) {
      return null;
    }
    for (x = _k = 0; 0 <= n_blanks_on_left ? _k < n_blanks_on_left : _k > n_blanks_on_left; x = 0 <= n_blanks_on_left ? ++_k : --_k) {
      syms.push('blank');
    }
    syms = syms.concat(normal_syms);
    return syms;
  };

  self.parse = parse;

  self.textToFlapSymbols = function(symbols) {
    var sym, valid, _k, _len2, _ref2, _ref3;
    if (symbols instanceof Array) {
      valid = true;
      valid = valid && (symbols.length === 7);
      symbols = symbols.map(convert_digit);
      valid = valid && (_ref2 = symbols[0], __indexOf.call(lead_byte_array, _ref2) >= 0);
      _ref3 = symbols.slice(1, 7);
      for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
        sym = _ref3[_k];
        valid = valid && (__indexOf.call(byte_array, sym) >= 0);
      }
      if (valid) {
        return symbols;
      } else {
        return null;
      }
    } else if ((typeof symbols) === 'string') {
      return parse(symbols);
    }
  };

}).call(this);
